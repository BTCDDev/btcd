--- nanomsg-new/src/transports/tcp/ctcp.c	2015-08-20 18:32:06.201391970 +0700
+++ ctcp.1	2015-08-20 20:20:19.301598252 +0700
@@ -111,6 +111,32 @@
 static void nn_ctcp_start_connecting (struct nn_ctcp *self,
     struct sockaddr_storage *ss, size_t sslen);
 
+int32_t conv_domain(struct sockaddr_storage *ss,const char *addr,int32_t ipv4only)
+{
+    //struct nn_dns dns; struct nn_dns_result dns_result;
+    size_t addrlen,sslen;
+    const char *semicolon,*hostname,*colon,*end;
+    addrlen = strlen(addr);
+    semicolon = strchr(addr,';');
+    hostname = semicolon ? semicolon + 1 : addr;
+    colon = strrchr(addr,':');
+    end = addr + addrlen;
+    if ( nn_slow(!colon) ) // Parse the port
+        return -EINVAL;
+    if ( nn_slow(nn_port_resolve (colon + 1, end - colon - 1) < 0) )
+        return -EINVAL;
+    //  Check whether the host portion of the address is either a literal or a valid hostname.
+    if ( nn_dns_check_hostname(hostname,colon - hostname) < 0 && nn_literal_resolve(hostname,colon - hostname,ipv4only,ss,&sslen) < 0 )
+        return -EINVAL;
+    if ( semicolon != 0 && nn_iface_resolve(addr,semicolon - addr,ipv4only,ss,&sslen) < 0 ) // If local address is specified, check whether it is valid
+        return -ENODEV;
+    //memset(&dns_result,0,sizeof(dns_result));
+   // nn_dns_start(&dns,addr,addrlen,ipv4only,&dns_result);
+   // while ( *(uint32_t *)&dns_result.addr == 0 )
+    //    usleep(10000);
+    return(0);
+}
+
 int nn_ctcp_create (void *hint, struct nn_epbase **epbase)
 {
     int rc;
